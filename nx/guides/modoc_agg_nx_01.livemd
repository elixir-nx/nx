# Livebook companion for Nx

```elixir
Mix.install([
  {:nx, "~> 0.4.2"},
  {:kino, "~> 0.8"}
])

# import IEx.Helpers
```

## Aggregations operations on tensors



```elixir
import Nx, only: :sigils
```

A tensor _in computer science_ can be viewed as a list of multi-indexed numbers. You simply wrap your list with `Nx.tensor`. Equivalently, you can use the compact `~V` sigil:

```elixir
{
  Nx.tensor([1, 2, 3]),
  ~V[1 2 3],
  Nx.tensor([[1, 2], [3, 4]]),
  ~M[
    1 2
    3 4
  ]
}
```

You can apply aggregation functions on any tensor. The function can be applied to tensor as a whole or to a subsection of the tensor taken in an axis-wise fashion. For instance, you could get the maximum number in a matrix (2D tensor) with `Nx.reduce_max(matrix)`, returning a scalar (0D tensor); or the maximum number for each row with `Nx.reduce_max(matrix, axes: [1])`, returning a vector (1D tensor).

Let's take a first example with the `Nx.all_close` full-tensor aggregate.  For each element of your tensor, you make a comparison against a given tensor and evaluate how "close" globally these tensors are.

As an application, we use a tensor of rank 1 (a vector) and compare the calculations done by hand with the aggregate function `Nx.variance` (which returns a tensor of rank 0 if not aggregated axis-wise).

```elixir
l = ~V[0 1 2]

mean = (0 + 1 + 2) / 3 # == 1
variance = ((0 - mean) ** 2 + (1 - mean) ** 2 + (2 - mean) ** 2) / 3 # == ((-1)**2 + (0)**2 + (1)**2 / 3 == 2/3 or 0.66...

nx_variance = Nx.variance(l)

%{
  hand_variance: variance,
  nx_variance: nx_variance,
  variance_result_rank: Nx.rank(nx_variance),
  _nx_close_agg: Nx.all_close(Nx.tensor(variance, type: :f16), nx_variance)
}
```

Let's take an example of the aggregate `Nx.weighted_mean` that supports full-tensor and per axis operations. Let's take an example with a tensor of rank 2; these are vectors, covectors and 2D matrices. Let's check how the weighted mean aggregate of a matrix is computed with a 2D tensor of shape`{2,2}` (aka as "square matrix").

```elixir
m = ~M[
  1 2
  3 4
]
```

We run the full -tensor aggregate, do the same calculations by hand and finally compare them:

```elixir
full_weights = ~V[4 5 4 5] |> Nx.reshape({2, 2})
nx_w_avg = Nx.weighted_mean(m, full_weights)

man_w_avg = (1 * 4 + 2 * 5 + 3 * 4 + 4 * 5) / (4 + 5 + 4 + 5)

%{
  nx_weighted_avg: Nx.to_number(nx_w_avg),
  manual_weighted_avg: man_w_avg,
  _nx_close: Nx.all_close(nx_w_avg, Nx.tensor(man_w_avg))
}
```

The weighted mean can be run per axis. Let's take an example of the same squared matrix along the **first** axis (`axes: [0]`) with the same weights per axis: you calculate "by column", so aggregate all elements with the second remaining index 1 constant, or equivalently "reduce" along the selected axis (the first index):

```elixir
axes_weights = ~V[4 5]
w_avg_x = Nx.weighted_mean(m, axes_weights, axes: [0])

man_w_avg_x = [(1 * 4 + 3 * 5) / (4 + 5), (2 * 4 + 4 * 5) / (4 + 5)]

{
  w_avg_x,
  man_w_avg_x,
  Nx.all_close(w_avg_x, Nx.tensor(man_w_avg_x))
}
```

We calculate weighted mean of a square matrix along the **second** axis with a set of different weights per axis: you calculate per row, so you aggregate all elements the the same remaining. index fiexd (the first index), equivalently reduce along the second axis.

```elixir
x0_weights = ~V[4 5]
x1_weights = ~V[5 4]
weights = Nx.concatenate([x0_weights, x1_weights]) |> Nx.reshape({2, 2})

nx_w_avg_y = Nx.weighted_mean(m, weights, axes: [1])

man_w_avg_y = [(1 * 4 + 2 * 5) / (4 + 5), (3 * 5 + 4 * 4) / (4 + 5)]

{
  nx_w_avg_y,
  man_w_avg_y,
  Nx.all_close(nx_w_avg_y, Nx.tensor(man_w_avg_y))
}
```

#### Example with higher rank

The example below will be used through the documentation.

Take a list of numbers of length $n=36$, and turn it into a tensor with the shape `{2,3,2,3}`; this is a computational tensor of rank 4. We will _name_ the axes, with `names: [:x, :y, :z, :t]`.

```elixir
t =
  ~V[1 2 3 1 -2 3 4 -3 2 -4 3 2 5 -1 3 -5 1 3 4 6 1 4 -6 1 1 2 3 1 -2 3 4 -3 2 -4 3 2]
  |> Nx.reshape({2, 3, 2, 3}, names: [:x, :y, :z, :t])
```

We can view this list as a succession of slices into rows given by the shape of the tensor. With the shape `{2,3,2,4}`, you obtain slices of length $2$,then $3$, then $2$ and the last index of length $4$ is conventionally represented as a row. The picture below will help to understand the aggregations.

$$
\begin{bmatrix} x=0
  \begin{bmatrix} y=0

\begin{bmatrix}
  a_{0,0,0,0} & a_{0,0,0,1} & a_{0,0,0,2} \\
  a_{0,0,1,0} & a_{0,0,1,1} & a_{0,0,1,2} \\
\end{bmatrix}
\\ 
y=1
\begin{bmatrix} 
  a_{0,1,0,0} & a_{0,1,0,1} & a_{0,1,0,2} \\
  a_{0,1,1,0} & a_{0,1,1,1} & a_{0,1,1,2} \\
\end{bmatrix}
\\ 
y=2
\begin{bmatrix}
  a_{0,2,0,0} & a_{0,2,0,1} & a_{0,2,0,2} \\
  a_{0,2,1,0} & a_{0,2,1,1} & a_{0,2,1,2} \\
\end{bmatrix}

\end{bmatrix}
  \\

x=1

\begin{bmatrix} y=0

\begin{bmatrix}
  a_{1,0,0,0} & a_{1,0,0,1} & a_{1,0,0,2}  \\
  a_{1,0,1,0} & a_{1,0,1,1} & a_{1,0,1,2}  \\
\end{bmatrix}
\\ 
y=1
\begin{bmatrix}
  a_{1,1,0,0} & a_{1,1,0,1} & a_{1,1,0,2}  \\
  a_{1,1,1,0} & a_{1,1,1,1} & a_{1,1,1,2}  \\
\end{bmatrix}
\\ 
y=2
\begin{bmatrix}
  a_{1,2,0,0} & a_{1,2,0,1} & a_{1,2,0,2}  \\
  a_{1,2,1,0} & a_{1,2,1,1} & a_{1,2,1,2}  \\    
\end{bmatrix}

\end{bmatrix}
\end{bmatrix}



\begin{bmatrix} x=0
  \begin{bmatrix} y=0

```
\begin{bmatrix}
  & 1, 2, 3, & \\
  & 1, -2, 3, &
\end{bmatrix}
\\ 
y=1
\begin{bmatrix} 
  & 4, -3, 2 & \\
  & -4, 3, 2 &
\end{bmatrix}
\\ 
y=2
\begin{bmatrix}
  & 5, -1, 3 &\\
  & -5, 1, 3 &
\end{bmatrix}
```

\end{bmatrix}
  \\
  x=1
  \begin{bmatrix} y=0

```
\begin{bmatrix}
  & 4, 6, 1 & \\
  & 4, -6, 1 &
\end{bmatrix}
\\ 
y=1
\begin{bmatrix}
  & 1, 2, 3 & \\
  & 1, -2, 3 &
\end{bmatrix}
\\ 
y=2
\begin{bmatrix}
  & 4, -3, 2 & \\
  & -4, 3, 2 &
\end{bmatrix}
```

\end{bmatrix}
\end{bmatrix}
$$

<!-- livebook:{"break_markdown":true} -->

Firstly, let's check some characteristics of this tensor: they use full tensor aggregation functions.

```elixir
%{
  dimensions: %{
    x: Nx.axis_size(t, :x),
    y: Nx.axis_size(t, :y),
    z: Nx.axis_size(t, :z),
    t: Nx.axis_size(t, :t)
  },
  n: Nx.size(t),
  shape: Nx.shape(t),
  rank: Nx.rank(t),
  analysis: %{
    most_frequent_nb: Nx.mode(t) |> Nx.to_number(),
    smallest_element: %{
      value: Nx.reduce_min(t) |> Nx.to_number(),
      position: Nx.argmin(t) |> Nx.to_number()
    },
    greatest_element: %{
      value: Nx.reduce_max(t) |> Nx.to_number(),
      position: Nx.argmax(t) |> Nx.to_number()
    },
    no_zero_nb: Nx.all(t) |> Nx.to_number()
  }
}
```

#### Single row aggregation, along an axis

> ‚ùó We are going to use the key `:axis` below. The following functions `argmin`, `argmax`, `median` and `mode` use `:axis: <symbol> or number` in singular mode. All of the other aggregating functions use `axes: [<symbol> or number]`; these have multi-axis aggregation implemented.

When you aggregate along an axis, you are going to reshape the tensor and to aggregate with a function, in other words perform a reduction. It is important to consider the _ordering_ of the axes.

<!-- livebook:{"break_markdown":true} -->

###### Aggregate along the first axis `axis: :x` (equivalently `axis: 0`).

The shape of our original tensor  `t`  is `[x: 2, y: 3, z: 2, t: 3]`. When we aggregate along the axis `:x`, it collapses and the shape of the resultant tensor `r` is `[y: 3,z: 2,t: 3]`. The rule is that every axis before the selected one will remain in the structure of the tensor as well as every axis after the selected one.

How? You collect from each slice of `x` the elements that have the _same_ remaining indexes "on the right" $y,z,t$. In the case of our tensor, you have 2 `x`-slices so you build a sublist of 2 elements, and then apply the aggregating function on it. This gives you the value of the resulting tensor $r$ at the location $r[y][z][t]$:

$$
\rm{agg}\big(t[0][y][z][t], t[1][y][z][t]\big) = r[y][z][t]
$$

The aggregating function used below is `argmin`: the index of the smallest element of the  sublist. In case of several occurences, the `:tie_break` attribute takes the lowest index.

$$
\begin{bmatrix} x=0
  \begin{bmatrix} y=0

```
\begin{bmatrix}
  & \boxed{1}, 2, 3, & \\
  & 1, -2, 3, &
\end{bmatrix}
\\ 
y=1
\begin{bmatrix} 
  & 4, -3, 2 & \\
  & -4, 3, 2 &
\end{bmatrix}
\\ 
y=2
\begin{bmatrix}
  & 5, -1, 3 &\\
  & -5, 1, 3 &
\end{bmatrix}
```

\end{bmatrix}
  \\
  x=1
  \begin{bmatrix} y=0

```
\begin{bmatrix}
  & \boxed{4}, 6, 1 & \\
  & 4, -6, 1 &
\end{bmatrix}
\\ 
y=1
\begin{bmatrix}
  & 1, 2, 3 & \\
  & 1, -2, 3 &
\end{bmatrix}
\\ 
y=2
\begin{bmatrix}
  & 4, -3, 2 & \\
  & -4, 3, 2 &
\end{bmatrix}
```

\end{bmatrix}
\end{bmatrix}

\to
  \begin{bmatrix} y=0

```
\begin{bmatrix}
  & \boxed{\rm{agg}(1,4)}, \rm{agg}(2,6), \rm{agg}(3, 1)& \\
  & \rm{agg}(1,4), \rm{agg}(-2,-6), \rm{agg}(3,1) &
\end{bmatrix}
\\ 
y=1
\begin{bmatrix} 
  & \rm{agg}(4,1), \rm{agg}(-3,2), \rm{agg}(2,3) & \\
  & \rm{agg}(-4,1), \rm{agg}(3,-2), \rm{agg}(2,3) &
\end{bmatrix}
\\ 
y=2
\begin{bmatrix}
  & \rm{agg}(5,4), \rm{agg}(-1,-3), \rm{agg}(3,2) &\\
  & \rm{agg}(-5,-4), \rm{agg}(1,3), \rm{agg}(3,2) &
\end{bmatrix}
```

\end{bmatrix}

\xrightarrow[]{\rm{argmin}}

\begin{bmatrix}

```
\begin{bmatrix}
  & 0,0, 1 & \\
  & 0, 1,1 &
\end{bmatrix}
\\ 
\begin{bmatrix} 
  & 1, 0,0 & \\
  & 0,1,0 &
\end{bmatrix}
\\ 
\begin{bmatrix}
  & 1, 1,1 &\\
  & 0, 0,1 &
\end{bmatrix}
```

\end{bmatrix}
$$

```elixir
Nx.argmin(t, axis: :x)
```

###### Aggregate along the second axis `axis: :y` (equivalently `axis: 1`) .

The axis `y` will collapse and the shape of the resultant tensor `r` is `[x: 2, z: 2, t: 3]`.

How? The axis $x$ is before the selected one $y$ so it will remain. We therefor apply the procedure as above for _each_ sub $x$-slice.

More precisely, fix the $x$-slice,  and let's consider the $x=1$ one. You collect in each sub `y`-slice the elements with the same remaining indexes "on the right", $z,t$ (and $x$ of course). You apply the aggregation and the result will be the value at location $r[1][z][t]$ of the resultant tensor $r$. So the elements of the slice $x=1$ of the resultant tensor $r$ will be:

$$
r[x_{=1}][z][t] = \rm{agg}\big([t[x_{=1}][0][z][t], t[x_{=1}][1][z][t], t[x_{=1}][2][z][t]\big)
$$

You repeat this operation for each $x$-slice.

In the example below, we used again the `argmin` function.

$$
\begin{bmatrix} x=0
  \begin{bmatrix} y=0

```
\begin{bmatrix}
  & \boxed{1}, 2, 3, & \\
  & 1, -2, 3, &
\end{bmatrix}
\\ 
y=1
\begin{bmatrix} 
  & \boxed{4}, -3, 2 & \\
  & -4, 3, 2 &
\end{bmatrix}
\\ 
y=2
\begin{bmatrix}
  & \boxed{5}, -1, 3 &\\
  & -5, 1, 3 &
\end{bmatrix}
```

\end{bmatrix}
  \\
  x=1
  \begin{bmatrix} y=0

```
\begin{bmatrix}
  & 4, 6, 1 & \\
  & 4, \boxed{-6}, 1 &
\end{bmatrix}
\\ 
y=1
\begin{bmatrix}
  & 1, 2, 3 & \\
  & 1, \boxed{-2}, 3 &
\end{bmatrix}
\\ 
y=2
\begin{bmatrix}
  & 4, -3, 2 & \\
  & -4, \boxed{3}, 2 &
\end{bmatrix}
```

\end{bmatrix}
\end{bmatrix}

\to
  \begin{bmatrix} x=0

```
\begin{bmatrix}
  &\boxed{\rm{agg}(1,4,5)}, \rm{agg}(2,-3,-1), \rm{agg}(3, 2,3)& \\
  & \rm{agg}(1,-4,-5), \rm{agg}(-2,3,1), \rm{agg}(3,2,3) &
\end{bmatrix}
\\ 
x=1
\begin{bmatrix} 
  & \rm{agg}(4,1,4), \rm{agg}(6,2,-3), \rm{agg}(1,3,2) & \\
  & \rm{agg}(4,1,-4), \boxed{\rm{agg}(-6,-2,3)}, \rm{agg}(1,3,2) &
\end{bmatrix}
```

\end{bmatrix}

\xrightarrow[]{\rm{argmin}}

\begin{bmatrix}

```
\begin{bmatrix}
  & 0, 2, 1 & \\
  & 2, 0,1 &
\end{bmatrix}
\\ 
\begin{bmatrix} 
  & 1, 2,0 & \\
  & 2,0,0 &
\end{bmatrix}
```

\end{bmatrix}
$$

```elixir
Nx.argmin(t, axis: 1)
```

###### Aggregate along the `axis: :z` axis (equivalently `axis: 2`).

The `z` axis collapse and the shape of the resultant tensor `r`is `[x: 2, y: 3, t: 3]`. You now have understood that we will, for each $x$-slices and each $y$-slices on the left, collect the elements of the slice with the same remain indexes "on the right", thus $t$ here.

$$
r[x][y][t] = \rm{agg}\big(t[x][y][0][t], (t[x][y][1][t] \big)
$$

In the example below, we used the `argmax` function.

$$
\begin{bmatrix} x=0
  \begin{bmatrix} y=0

```
\begin{bmatrix}
  \boxed{1}, 2, 3, & \\
  \boxed{1}, -2, 3, &
\end{bmatrix}
\\ 
y=1
\begin{bmatrix} 
  & 4, -3, 2 & \\
  & -4, 3, 2 &
\end{bmatrix}
\\ 
y=2
\begin{bmatrix}
  & 5, -1, 3 &\\
  & -5, 1, 3 &
\end{bmatrix}
```

\end{bmatrix}
  \\
  x=1
  \begin{bmatrix} y=0

```
\begin{bmatrix}
   & 4, \boxed{6}, 1  \\
   & 4,\boxed{-6}, 1 
\end{bmatrix}
\\ 
y=1
\begin{bmatrix}
  & 1, 2, 3 & \\
  & 1, -2, 3 &
\end{bmatrix}
\\ 
y=2
\begin{bmatrix}
  & 4, -3, 2 & \\
  & -4, 3, 2 &
\end{bmatrix}
```

\end{bmatrix}
\end{bmatrix}

\to
  \begin{bmatrix} x=0

```
\begin{bmatrix}
  & \boxed{\rm{agg}(1,1)}, \rm{agg}(2,-2), \rm{agg}(3,3)& \\
  & \rm{agg}(4,-4), \rm{agg}(-3,3), \rm{agg}(2,2) & \\
  & \rm{agg}(5,-5), \rm{agg}(-1,1), \rm{agg}(3,3)
\end{bmatrix}
\\ 
x=1
\begin{bmatrix} 
  & \rm{agg}(4,4), \boxed{\rm{agg}(6,-6)}, \rm{agg}(1,1) & \\
  & \rm{agg}(1,1), \rm{agg}(2,-2), \rm{agg}(3,3) & \\
  & \rm{agg}(4,-4), \rm{agg}(-3,3), \rm{agg}(2,2) &
\end{bmatrix}
```

\end{bmatrix}

\xrightarrow[]{\rm{argmax}}

\begin{bmatrix}

```
\begin{bmatrix}
  & 0, 0, 0 & \\
  & 0, 1, 0 & \\
  & 0, 1, 0
\end{bmatrix}
\\ 
\begin{bmatrix} 
  & 0, 0, 0 & \\
  & 0, 0, 0 & \\
  & 0, 1, 0
\end{bmatrix}
```

\end{bmatrix}
$$

```elixir
Nx.argmax(t, axis: :z)
```

###### Aggregate along the last axis, `axis: :t` or (`axis: 3` or `axis: -1`).

This will reshape the tensor to `[x: 2, y: 3, z: 2]`. Since this is the last index, having in mind the matrix picture above, you aggregate along each row:

$$
r[x][y][z] = \rm{agg}\big(t[x][y][z]0,  t[x][y][z]1, t[x][y][z]2\big)
$$

and repeat this for each $x$-slice, each sub $y$-slice, each sub-sub $z$-slice.

Below is the result for the function `argmin`.

$$
\begin{bmatrix} x=0
  \begin{bmatrix} y=0

```
\begin{bmatrix}
  & \boxed{1, 2, 3}, & \\
  & 1, -2, 3, &
\end{bmatrix}
\\ 
y=1
\begin{bmatrix} 
  & 4, -3, 2 & \\
  & -4, 3, 2 &
\end{bmatrix}
\\ 
y=2
\begin{bmatrix}
  & 5, -1, 3 &\\
  & -5, 1, 3 &
\end{bmatrix}
```

\end{bmatrix}
  \\
  x=1
  \begin{bmatrix} y=0

```
\begin{bmatrix}
  & 4, 6, 1 & \\
  & 4,-6, 1 &
\end{bmatrix}
\\ 
y=1
\begin{bmatrix}
  & 1, 2, 3 & \\
  & \boxed{1, -2, 3} &
\end{bmatrix}
\\ 
y=2
\begin{bmatrix}
  & 4, -3, 2 & \\
  & -4, 3, 2 &
\end{bmatrix}
```

\end{bmatrix}
\end{bmatrix}

\xrightarrow[]{\rm{argmin}}

\begin{bmatrix}

```
\begin{bmatrix}
  & \boxed{0}, 1 & \\
  & 1, 0 & \\
  & 1, 0
\end{bmatrix}
\\ 
\begin{bmatrix} 
  & 2, 1 & \\
  & 0, \boxed{1} & \\
  & 1, 0
\end{bmatrix}
```

\end{bmatrix}
$$

```elixir
Nx.argmin(t, axis: 3)
```

#### Option `:tie_break`

You have the `:tie_break` option to decide how to operate with you have several occurences of the result. It defaults to `tie_break: :low`.

```elixir
t4 = ~V[2 0 0 0 1]

%{
  argmin_with_default: Nx.argmin(t4) |> Nx.to_number(),
  argmin_with_tie_break_high_option: Nx.argmin(t4, tie_break: :high) |> Nx.to_number()
}
```

#### Option `:keep_axis`

Its default value is `false` but when this option set to `keep_axis: true`, you reshape the resulting tensor with a new shape where the dimension of the working axis to $1$. For example, `Nx.argmax(t, axis: :y, keep_axix: true)` will have a shape a `[x: 2,y: 1,z: 2, t: 3]`. This mean that:

```elixir
Nx.argmin(t, axis: 1, keep_axis: true) ==
  Nx.argmin(t, axis: 1) |> Nx.reshape({2, 1, 2, 3}, names: [:x, :y, :z, :t])
```

$$
\begin{bmatrix}
  \begin{bmatrix}

```
& 0, 2, 1 & \\
& 2, 0,1 &
```

\end{bmatrix}
  \\ 
  \begin{bmatrix}

```
& 1, 2,0 & \\
& 2,0,0 &
```

\end{bmatrix}
\end{bmatrix}

\to

\begin{bmatrix}
  \begin{bmatrix}

```
  \begin{bmatrix}
    & 0, 2, 1 & \\
    & 2, 0,1 &
  \end{bmatrix}
```

\end{bmatrix}
  \\ 
  \begin{bmatrix}

```
  \begin{bmatrix}
    & 1, 2,0 & \\
    & 2,0,0 &
  \end{bmatrix}
```

\end{bmatrix}
\end{bmatrix}
$$

<!-- livebook:{"break_markdown":true} -->

#### Multi-row aggregation

<!-- livebook:{"break_markdown":true} -->

Suppose you want to aggregate along the axis `x` and `z`. Then you should get a tensor of shape `[y: 3, t: 3]`. Given an index `x` and `z`, you aggregate all the numbers with the same indexes $(y,t)$.

$$
r[y][t] = \rm{agg}\big( t0[y]0[t], t0[y]1[t], t1[y]0[t], t1[y]1[t]\big)

<!-- livebook:{"break_markdown":true} -->

From this, it is easier to understand what the following aggregation calls return:

```elixir
Nx.reduce_min(t, axes: [0, 2])
```

```elixir
Nx.reduce_max(t, axes: [:x, :t])
```

```elixir
Nx.mean(t, axes: [:x, :y])
```
